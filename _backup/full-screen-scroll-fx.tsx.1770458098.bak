'use client'

import React, {
  CSSProperties,
  ReactNode,
  forwardRef,
  useCallback,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from 'react'
import { gsap } from 'gsap'
import { ScrollTrigger } from 'gsap/ScrollTrigger'

if (typeof window !== 'undefined') {
  gsap.registerPlugin(ScrollTrigger)
}

type Section = {
  id?: string
  background: string
  leftLabel?: ReactNode
  title: string | ReactNode
  rightLabel?: ReactNode
  renderBackground?: (active: boolean, previous: boolean) => ReactNode
}

type Colors = Partial<{
  text: string
  overlay: string
  pageBg: string
  stageBg: string
}>

type Durations = Partial<{
  change: number
  snap: number
}>

export type FullScreenFXAPI = {
  next: () => void
  prev: () => void
  goTo: (index: number) => void
  getIndex: () => number
  refresh: () => void
}

export type FullScreenFXProps = {
  sections: Section[]
  className?: string
  style?: CSSProperties
  fontFamily?: string
  header?: ReactNode
  footer?: ReactNode
  gap?: number
  gridPaddingX?: number
  showProgress?: boolean
  debug?: boolean
  durations?: Durations
  reduceMotion?: boolean
  smoothScroll?: boolean
  bgTransition?: 'fade' | 'wipe'
  parallaxAmount?: number
  currentIndex?: number
  onIndexChange?: (index: number) => void
  initialIndex?: number
  colors?: Colors
  apiRef?: React.Ref<FullScreenFXAPI>
  ariaLabel?: string
}

const clamp = (n: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, n))

export const FullScreenScrollFX = forwardRef<HTMLDivElement, FullScreenFXProps>(
  (
    {
      sections,
      className,
      style,
      fontFamily = '"Rubik Wide", system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif',
      header,
      footer,
      gap = 1,
      gridPaddingX = 2,
      showProgress = true,
      debug = false,
      durations = { change: 0.72, snap: 800 },
      reduceMotion,
      smoothScroll = false,
      bgTransition = 'fade',
      parallaxAmount = 4,
      currentIndex,
      onIndexChange,
      initialIndex = 0,
      colors = {
        text: 'rgba(245,245,245,0.96)',
        overlay: 'rgba(0,0,0,0.45)',
        pageBg: '#000000',
        stageBg: '#000000',
      },
      apiRef,
      ariaLabel = 'Full screen scroll slideshow',
    },
    ref
  ) => {
    const safeSections = useMemo<Section[]>(
      () =>
        sections && sections.length
          ? sections
          : [
              {
                id: 'fallback',
                background: '/branding/logo-round.png',
                title: 'JULIA LEBEDEVA COLLECTION',
                leftLabel: '',
                rightLabel: '',
              },
            ],
      [sections]
    )

    const total = safeSections.length
    const [localIndex, setLocalIndex] = useState(clamp(initialIndex, 0, Math.max(0, total - 1)))
    const isControlled = typeof currentIndex === 'number'
    const index = isControlled ? clamp(currentIndex as number, 0, Math.max(0, total - 1)) : localIndex

    useEffect(() => {
      if (!isControlled && localIndex > total - 1) setLocalIndex(Math.max(0, total - 1))
    }, [isControlled, localIndex, total])

    const rootRef = useRef<HTMLDivElement | null>(null)
    const fixedRef = useRef<HTMLDivElement | null>(null)
    const fixedSectionRef = useRef<HTMLDivElement | null>(null)

    const bgRefs = useRef<HTMLImageElement[]>([])
    const featuredRefs = useRef<HTMLDivElement[]>([])

    const leftTrackRef = useRef<HTMLDivElement | null>(null)
    const rightTrackRef = useRef<HTMLDivElement | null>(null)
    const leftItemRefs = useRef<HTMLDivElement[]>([])
    const rightItemRefs = useRef<HTMLDivElement[]>([])

    const progressFillRef = useRef<HTMLDivElement | null>(null)
    const currentNumberRef = useRef<HTMLSpanElement | null>(null)

    const stRef = useRef<ScrollTrigger | null>(null)
    const lastIndexRef = useRef(index)
    const isAnimatingRef = useRef(false)
    const isSnappingRef = useRef(false)
    const sectionTopRef = useRef<number[]>([])

    const prefersReduced = useMemo(() => {
      if (typeof window === 'undefined') return false
      return window.matchMedia?.('(prefers-reduced-motion: reduce)').matches ?? false
    }, [])
    const motionOff = reduceMotion ?? prefersReduced

    const setProgress = useCallback(
      (i: number) => {
        if (currentNumberRef.current) {
          currentNumberRef.current.textContent = String(i + 1).padStart(2, '0')
        }
        if (progressFillRef.current) {
          const p = (i / (total - 1 || 1)) * 100
          progressFillRef.current.style.width = `${p}%`
        }
      },
      [total]
    )

    const computePositions = useCallback(() => {
      const fs = fixedSectionRef.current
      if (!fs) return
      const top = fs.offsetTop
      const h = fs.offsetHeight
      const arr: number[] = []
      for (let i = 0; i < total; i++) arr.push(top + (h * i) / total)
      sectionTopRef.current = arr
    }, [total])

    const measureAndCenterLists = useCallback(
      (toIndex = index, animate = true) => {
        const centerTrack = (container: HTMLDivElement | null, items: HTMLDivElement[], track: HTMLDivElement | null) => {
          if (!container || !track || items.length === 0) return
          const first = items[0]
          const second = items[1]
          const contRect = container.getBoundingClientRect()
          let rowH = first.getBoundingClientRect().height
          if (second) rowH = second.getBoundingClientRect().top - first.getBoundingClientRect().top
          const targetY = contRect.height / 2 - rowH / 2 - toIndex * rowH
          if (animate) {
            gsap.to(track, {
              y: targetY,
              duration: (durations.change ?? 0.72) * 0.9,
              ease: 'power3.out',
            })
          } else {
            gsap.set(track, { y: targetY })
          }
        }

        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            centerTrack(leftTrackRef.current, leftItemRefs.current, leftTrackRef.current)
            centerTrack(rightTrackRef.current, rightItemRefs.current, rightTrackRef.current)
          })
        })
      },
      [durations.change, index]
    )

    const changeSection = useCallback(
      (to: number) => {
        const target = clamp(to, 0, total - 1)
        if (target === lastIndexRef.current || isAnimatingRef.current) return

        const from = lastIndexRef.current
        const down = target > from
        const D = durations.change ?? 0.72

        isAnimatingRef.current = true

        if (!isControlled) setLocalIndex(target)
        onIndexChange?.(target)
        setProgress(target)

        const outTitle = featuredRefs.current[from]
        const inTitle = featuredRefs.current[target]

        if (outTitle) {
          gsap.to(outTitle, {
            opacity: 0,
            y: down ? -20 : 20,
            duration: D * 0.55,
            ease: 'power3.out',
          })
        }
        if (inTitle) {
          gsap.fromTo(
            inTitle,
            { opacity: 0, y: down ? 20 : -20 },
            { opacity: 1, y: 0, duration: D, ease: 'power3.out' }
          )
        }

        const prevBg = bgRefs.current[from]
        const newBg = bgRefs.current[target]

        if (bgTransition === 'fade') {
          if (newBg) {
            gsap.set(newBg, { opacity: 0, scale: 1.04, yPercent: down ? 1 : -1 })
            gsap.to(newBg, {
              opacity: 1,
              scale: 1,
              yPercent: 0,
              duration: D,
              ease: 'power2.out',
            })
          }
          if (prevBg) {
            gsap.to(prevBg, {
              opacity: 0,
              yPercent: down ? -parallaxAmount : parallaxAmount,
              duration: D,
              ease: 'power2.out',
            })
          }
        } else {
          if (newBg) {
            gsap.set(newBg, {
              opacity: 1,
              clipPath: down ? 'inset(100% 0 0 0)' : 'inset(0 0 100% 0)',
              scale: 1,
              yPercent: 0,
            })
            gsap.to(newBg, {
              clipPath: 'inset(0 0 0 0)',
              duration: D,
              ease: 'power3.out',
            })
          }
          if (prevBg) {
            gsap.to(prevBg, { opacity: 0, duration: D * 0.8, ease: 'power2.out' })
          }
        }

        measureAndCenterLists(target, true)

        leftItemRefs.current.forEach((el, i) => {
          el.classList.toggle('active', i === target)
          gsap.to(el, {
            opacity: i === target ? 1 : 0.35,
            x: i === target ? 10 : 0,
            duration: D * 0.6,
            ease: 'power3.out',
          })
        })

        rightItemRefs.current.forEach((el, i) => {
          el.classList.toggle('active', i === target)
          gsap.to(el, {
            opacity: i === target ? 1 : 0.35,
            x: i === target ? -10 : 0,
            duration: D * 0.6,
            ease: 'power3.out',
          })
        })

        gsap.delayedCall(D, () => {
          lastIndexRef.current = target
          isAnimatingRef.current = false
        })
      },
      [
        bgTransition,
        durations.change,
        isControlled,
        measureAndCenterLists,
        onIndexChange,
        parallaxAmount,
        setProgress,
        total,
      ]
    )

    const goTo = useCallback(
      (to: number, withScroll = true) => {
        const target = clamp(to, 0, total - 1)
        isSnappingRef.current = true
        changeSection(target)

        const pos = sectionTopRef.current[target]
        const snapMs = durations.snap ?? 800

        if (withScroll && typeof window !== 'undefined' && Number.isFinite(pos)) {
          if (smoothScroll) {
            window.scrollTo({ top: pos, behavior: 'smooth' })
          } else {
            window.scrollTo({ top: pos, behavior: 'smooth' })
          }
          window.setTimeout(() => {
            isSnappingRef.current = false
          }, snapMs)
        } else {
          window.setTimeout(() => {
            isSnappingRef.current = false
          }, 10)
        }
      },
      [changeSection, durations.snap, smoothScroll, total]
    )

    const next = useCallback(() => goTo(index + 1), [goTo, index])
    const prev = useCallback(() => goTo(index - 1), [goTo, index])

    useImperativeHandle(
      apiRef,
      () => ({
        next,
        prev,
        goTo: (i: number) => goTo(i, true),
        getIndex: () => index,
        refresh: () => ScrollTrigger.refresh(),
      }),
      [goTo, index, next, prev]
    )

    useLayoutEffect(() => {
      if (typeof window === 'undefined') return
      const fixed = fixedRef.current
      const fs = fixedSectionRef.current
      if (!fixed || !fs || total === 0) return

      gsap.set(bgRefs.current, { opacity: 0, scale: 1.04, yPercent: 0 })
      if (bgRefs.current[0]) gsap.set(bgRefs.current[0], { opacity: 1, scale: 1 })

      featuredRefs.current.forEach((el, i) => {
        gsap.set(el, {
          opacity: i === index ? 1 : 0,
          y: 0,
        })
      })

      computePositions()
      measureAndCenterLists(index, false)
      setProgress(index)

      const st = ScrollTrigger.create({
        trigger: fs,
        start: 'top top',
        end: 'bottom bottom',
        pin: fixed,
        pinSpacing: true,
        onUpdate: (self) => {
          if (motionOff || isSnappingRef.current) return
          const target = Math.min(total - 1, Math.floor(self.progress * total))
          if (target !== lastIndexRef.current && !isAnimatingRef.current) {
            const step = target > lastIndexRef.current ? 1 : -1
            goTo(lastIndexRef.current + step, false)
          }
        },
      })

      stRef.current = st

      if (initialIndex > 0 && initialIndex < total) {
        requestAnimationFrame(() => goTo(initialIndex, false))
      }

      const ro = new ResizeObserver(() => {
        computePositions()
        measureAndCenterLists(lastIndexRef.current, false)
        ScrollTrigger.refresh()
      })
      ro.observe(fs)

      return () => {
        ro.disconnect()
        st.kill()
        stRef.current = null
      }
    }, [computePositions, goTo, index, initialIndex, measureAndCenterLists, motionOff, setProgress, total])

    useEffect(() => {
      leftItemRefs.current.forEach((el, i) => {
        gsap.fromTo(
          el,
          { opacity: 0, y: 18 },
          {
            opacity: i === index ? 1 : 0.35,
            y: 0,
            duration: 0.45,
            delay: i * 0.05,
            ease: 'power3.out',
          }
        )
      })

      rightItemRefs.current.forEach((el, i) => {
        gsap.fromTo(
          el,
          { opacity: 0, y: 18 },
          {
            opacity: i === index ? 1 : 0.35,
            y: 0,
            duration: 0.45,
            delay: 0.12 + i * 0.05,
            ease: 'power3.out',
          }
        )
      })

      measureAndCenterLists(index, false)
      setProgress(index)
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [])

    const cssVars: CSSProperties = {
      ['--fx-font' as any]: fontFamily,
      ['--fx-text' as any]: colors.text ?? 'rgba(245,245,245,0.96)',
      ['--fx-overlay' as any]: colors.overlay ?? 'rgba(0,0,0,0.45)',
      ['--fx-page-bg' as any]: colors.pageBg ?? '#000000',
      ['--fx-stage-bg' as any]: colors.stageBg ?? '#000000',
      ['--fx-gap' as any]: `${gap}rem`,
      ['--fx-grid-px' as any]: `${gridPaddingX}rem`,
      ['--fx-row-gap' as any]: '10px',
    }

    const handleJump = (i: number) => goTo(i, true)

    return (
      <div
        ref={(node) => {
          ;(rootRef as React.MutableRefObject<HTMLDivElement | null>).current = node
          if (typeof ref === 'function') ref(node)
          else if (ref) (ref as React.MutableRefObject<HTMLDivElement | null>).current = node
        }}
        className={['fx', className].filter(Boolean).join(' ')}
        style={{ ...cssVars, ...style }}
        aria-label={ariaLabel}
      >
        {debug && <div className='fx-debug'>Section: {index}</div>}

        <div className='fx-scroll'>
          <div className='fx-fixed-section' ref={fixedSectionRef}>
            <div className='fx-fixed' ref={fixedRef}>
              <div className='fx-bgs' aria-hidden='true'>
                {safeSections.map((s, i) => (
                  <div className='fx-bg' key={s.id ?? i}>
                    {s.renderBackground ? (
                      s.renderBackground(index === i, lastIndexRef.current === i)
                    ) : (
                      <>
                        <img
                          ref={(el) => {
                            if (el) bgRefs.current[i] = el
                          }}
                          src={s.background}
                          alt=''
                          className='fx-bg-img'
                        />
                        <div className='fx-bg-overlay' />
                      </>
                    )}
                  </div>
                ))}
              </div>

              <div className='fx-grid'>
                {header ? <div className='fx-header'>{header}</div> : null}

                <div className='fx-content'>
                  <div className='fx-left' role='list'>
                    <div className='fx-track' ref={leftTrackRef}>
                      {safeSections.map((s, i) => (
                        <div
                          key={`L-${s.id ?? i}`}
                          className={`fx-item fx-left-item ${i === index ? 'active' : ''}`}
                          ref={(el) => {
                            if (el) leftItemRefs.current[i] = el
                          }}
                          onClick={() => handleJump(i)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                              e.preventDefault()
                              handleJump(i)
                            }
                          }}
                          role='button'
                          tabIndex={0}
                          aria-pressed={i === index}
                        >
                          {s.leftLabel}
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className='fx-center'>
                    {safeSections.map((s, sIdx) => (
                      <div
                        key={`C-${s.id ?? sIdx}`}
                        className={`fx-featured ${sIdx === index ? 'active' : ''}`}
                        ref={(el) => {
                          if (el) featuredRefs.current[sIdx] = el
                        }}
                      >
                        <h3 className='fx-featured-title'>{s.title}</h3>
                      </div>
                    ))}
                  </div>

                  <div className='fx-right' role='list'>
                    <div className='fx-track' ref={rightTrackRef}>
                      {safeSections.map((s, i) => (
                        <div
                          key={`R-${s.id ?? i}`}
                          className={`fx-item fx-right-item ${i === index ? 'active' : ''}`}
                          ref={(el) => {
                            if (el) rightItemRefs.current[i] = el
                          }}
                          onClick={() => handleJump(i)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                              e.preventDefault()
                              handleJump(i)
                            }
                          }}
                          role='button'
                          tabIndex={0}
                          aria-pressed={i === index}
                        >
                          {s.rightLabel}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>

                <div className='fx-footer'>
                  {footer ? <div className='fx-footer-title'>{footer}</div> : null}
                  {showProgress ? (
                    <div className='fx-progress'>
                      <div className='fx-progress-numbers'>
                        <span ref={currentNumberRef}>{String(index + 1).padStart(2, '0')}</span>
                        <span>{String(total).padStart(2, '0')}</span>
                      </div>
                      <div className='fx-progress-bar'>
                        <div className='fx-progress-fill' ref={progressFillRef} />
                      </div>
                    </div>
                  ) : null}
                </div>
              </div>
            </div>
          </div>

          <div className='fx-end' />
        </div>

        <style jsx>{`
          .fx {
            width: 100%;
            overflow: hidden;
            background: var(--fx-page-bg);
            color: #000;
            font-family: var(--fx-font);
            letter-spacing: -0.02em;
          }

          .fx-debug {
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 9999;
            background: rgba(255, 255, 255, 0.8);
            color: #000;
            padding: 6px 8px;
            font: 12px/1 monospace;
            border-radius: 4px;
          }

          .fx-fixed-section {
            height: ${Math.max(1, total)}00vh;
            position: relative;
          }

          .fx-fixed {
            position: sticky;
            top: 0;
            height: 100vh;
            width: 100%;
            overflow: hidden;
            background: var(--fx-page-bg);
          }

          .fx-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: var(--fx-gap);
            padding: 0 var(--fx-grid-px);
            position: relative;
            height: 100%;
            z-index: 2;
          }

          .fx-bgs {
            position: absolute;
            inset: 0;
            background: var(--fx-stage-bg);
            z-index: 1;
          }

          .fx-bg {
            position: absolute;
            inset: 0;
          }

          .fx-bg-img {
            position: absolute;
            inset: -10% 0 -10% 0;
            width: 100%;
            height: 120%;
            object-fit: cover;
            filter: brightness(0.78);
            opacity: 0;
            will-change: transform, opacity;
          }

          .fx-bg-overlay {
            position: absolute;
            inset: 0;
            background: var(--fx-overlay);
          }

          .fx-header {
            grid-column: 1 / 13;
            align-self: start;
            padding-top: 8vh;
            font-size: clamp(2rem, 9vw, 8rem);
            line-height: 0.86;
            text-align: center;
            color: var(--fx-text);
            text-transform: uppercase;
          }

          .fx-header > * {
            display: block;
          }

          .fx-content {
            grid-column: 1 / 13;
            position: absolute;
            inset: 0;
            display: grid;
            grid-template-columns: 1fr 1.25fr 1fr;
            align-items: center;
            height: 100%;
            padding: 0 var(--fx-grid-px);
          }

          .fx-left,
          .fx-right {
            height: 60vh;
            overflow: hidden;
            display: grid;
            align-content: center;
          }

          .fx-left {
            justify-items: start;
          }

          .fx-right {
            justify-items: end;
          }

          .fx-track {
            will-change: transform;
          }

          .fx-item {
            color: var(--fx-text);
            font-weight: 800;
            line-height: 1;
            margin: calc(var(--fx-row-gap) / 2) 0;
            opacity: 0.35;
            transition: opacity 0.3s ease, transform 0.3s ease;
            position: relative;
            font-size: clamp(1rem, 2.4vw, 1.8rem);
            user-select: none;
            cursor: pointer;
            text-transform: uppercase;
          }

          .fx-left-item.active,
          .fx-right-item.active {
            opacity: 1;
          }

          .fx-left-item.active {
            transform: translateX(10px);
            padding-left: 16px;
          }

          .fx-right-item.active {
            transform: translateX(-10px);
            padding-right: 16px;
          }

          .fx-left-item.active::before,
          .fx-right-item.active::after {
            content: '';
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            background: var(--fx-text);
            border-radius: 50%;
          }

          .fx-left-item.active::before {
            left: 0;
          }

          .fx-right-item.active::after {
            right: 0;
          }

          .fx-center {
            display: grid;
            place-items: center;
            text-align: center;
            height: 60vh;
            overflow: hidden;
          }

          .fx-featured {
            position: absolute;
            left: 0;
            right: 0;
            margin: 0 auto;
            opacity: 0;
            visibility: hidden;
          }

          .fx-featured.active {
            opacity: 1;
            visibility: visible;
          }

          .fx-featured-title {
            margin: 0;
            color: var(--fx-text);
            font-weight: 900;
            letter-spacing: -0.01em;
            font-size: clamp(2rem, 7.8vw, 6rem);
            line-height: 0.95;
            text-transform: uppercase;
            text-wrap: balance;
          }

          .fx-footer {
            grid-column: 1 / 13;
            align-self: end;
            padding-bottom: 5vh;
            text-align: center;
          }

          .fx-footer-title {
            color: var(--fx-text);
            font-size: clamp(1rem, 2.6vw, 2.2rem);
            font-weight: 700;
            line-height: 1.15;
          }

          .fx-progress {
            width: 220px;
            height: 2px;
            margin: 0.9rem auto 0;
            background: rgba(245, 245, 245, 0.28);
            position: relative;
          }

          .fx-progress-fill {
            position: absolute;
            inset: 0 auto 0 0;
            width: 0%;
            background: var(--fx-text);
            height: 100%;
            transition: width 0.3s ease;
          }

          .fx-progress-numbers {
            position: absolute;
            inset: auto 0 100% 0;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            color: var(--fx-text);
          }

          .fx-end {
            display: none;
            height: 0;
          }

          @media (max-width: 1024px) {
            .fx-header {
              padding-top: 10vh;
              font-size: clamp(1.9rem, 11.5vw, 5rem);
            }

            .fx-featured-title {
              font-size: clamp(2rem, 11vw, 5rem);
            }
          }

          @media (max-width: 900px) {
            .fx-left,
            .fx-right {
              display: none;
            }

            .fx-content {
              grid-template-columns: 1fr;
              align-items: end;
              padding: 0 16px calc(110px + env(safe-area-inset-bottom));
            }

            .fx-center {
              min-height: 34vh;
              height: auto;
              margin-top: 0;
            }

            .fx-featured {
              position: relative;
              width: 92vw;
              max-width: 92vw;
            }

            .fx-featured-title {
              font-size: clamp(2.02rem, 13.2vw, 4.25rem);
              line-height: 0.95;
            }

            .fx-footer {
              padding-bottom: calc(22px + env(safe-area-inset-bottom));
            }

            .fx-footer-title {
              font-size: clamp(0.98rem, 5.1vw, 1.42rem);
              max-width: 92vw;
              margin: 0 auto;
              text-transform: none;
            }

            .fx-progress {
              width: min(240px, 62vw);
            }
          }
        `}</style>
      </div>
    )
  }
)

FullScreenScrollFX.displayName = 'FullScreenScrollFX'
export default FullScreenScrollFX
